<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - shaders - ocean</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>





		</style>
	</head>
	<body>
		<!--container-->

		<div id="container"></div>

		<canvas id="heightmap" width="128" height="128"></canvas>

		<!--three.js-->

		<script src="shared/js/three/three.js"></script>
		<script src="shared/js/three/OrbitControls.js"></script>
        <script src="shared/js/three/THREE.Terrain.min.js"></script>
		<script src="shared/js/three/Detector.js"></script>
		<script src="shared/js/three/stats.min.js"></script>

		<!--frameworks-->

		<script src="shared/js/frameworks/jquery-3.2.1.min.js"></script>
		<script src="shared/js/frameworks/physi.js"></script>
		<script src="shared/js/frameworks/WaterShader.js"></script>

		<!--loaders-->

		<script src="shared/js/loaders/OBJLoader.js"></script>
		<script src="shared/js/loaders/MTLLoader.js"></script>

		<!--classes-->


		<script>
            'use strict';

            Physijs.scripts.worker = 'shared/js/frameworks/physijs_worker.js';
            Physijs.scripts.ammo = 'ammo.js';

            if ( ! Detector.webgl ) {
                Detector.addGetWebGLMessage();
                document.getElementById( 'container' ).innerHTML = "";
            }

            var container, stats;
            var camera, scene, renderer;
            var controls, water, clock;

            var parameters = {
                width: 2000,
                height: 2000,
                widthSegments: 250,
                heightSegments: 250,
                depth: 1500,
                param: 4,
                filterparam: 1
            };

            var waterNormals;

			var modelsPath = "shared/models/";



            init();
            animate();

            function init() {

                clock = new THREE.Clock();

                container = document.getElementById( 'container' );

                // renderer

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );

                // scene

                scene = new Physijs.Scene();
                scene.fog = new THREE.FogExp2( 0xaabbbb, 0.0001 );
                scene.setGravity(new THREE.Vector3( 0, -100, 0 ));

                // camera

                camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.5, 3000000 );
                camera.position.set( 200, 75, 200 );

                // controls

                controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.enablePan = true;
                controls.maxDistance = 5000.0;
                controls.maxPolarAngle = Math.PI * 0.495;
                controls.target.set( 0, 100, 0 );
                controls.update();

                // light

				scene.add( new THREE.AmbientLight( 0x444444 ) );

                var light = new THREE.DirectionalLight( 0xffffbb, 1 );
                light.position.set( - 1, 1, - 1 );
                scene.add( light );

                // water

                waterNormals = new THREE.TextureLoader().load( modelsPath + 'textures/waternormals.jpg' );
                waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;

                water = new THREE.Water( renderer, camera, scene, {
                    textureWidth: 512,
                    textureHeight: 512,
                    waterNormals: waterNormals,
                    alpha: 	1.0,
                    sunDirection: light.position.clone().normalize(),
                    sunColor: 0xffffff,
                    waterColor: 0x001e0f,
                    distortionScale: 50.0,
                    fog: scene.fog != undefined
                } );


                var mirrorMesh = new THREE.Mesh(
                    new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
                    water.material
                );

                mirrorMesh.add( water );
                mirrorMesh.rotation.x = - Math.PI * 0.5;
                scene.add( mirrorMesh );

                // skybox

                var cubeMap = new THREE.CubeTexture( [] );
                cubeMap.format = THREE.RGBFormat;

                var loader = new THREE.ImageLoader();
                loader.load( modelsPath + 'textures/skybox.png', function ( image ) {

                    var getSide = function ( x, y ) {

                        var size = 1024;

                        var canvas = document.createElement( 'canvas' );
                        canvas.width = size;
                        canvas.height = size;

                        var context = canvas.getContext( '2d' );
                        context.drawImage( image, - x * size, - y * size );

                        return canvas;

                    };

                    cubeMap.images[ 0 ] = getSide( 2, 1 ); // px
                    cubeMap.images[ 1 ] = getSide( 0, 1 ); // nx
                    cubeMap.images[ 2 ] = getSide( 1, 0 ); // py
                    cubeMap.images[ 3 ] = getSide( 1, 2 ); // ny
                    cubeMap.images[ 4 ] = getSide( 1, 1 ); // pz
                    cubeMap.images[ 5 ] = getSide( 3, 1 ); // nz
                    cubeMap.needsUpdate = true;

                } );

                var cubeShader = THREE.ShaderLib[ 'cube' ];
                cubeShader.uniforms[ 'tCube' ].value = cubeMap;

                var skyBoxMaterial = new THREE.ShaderMaterial( {
                    fragmentShader: cubeShader.fragmentShader,
                    vertexShader: cubeShader.vertexShader,
                    uniforms: cubeShader.uniforms,
                    depthWrite: false,
                    side: THREE.BackSide
                } );

                var skyBox = new THREE.Mesh(
                    new THREE.BoxGeometry( 1000000, 1000000, 1000000 ),
                    skyBoxMaterial
                );

                scene.add( skyBox );

                //

                stats = new Stats();
                container.appendChild( stats.dom );

                //

                var tmaterial = THREE.Terrain.generateBlendedMaterial([
                    // The first texture is the base; other textures are blended in on top.
                    {texture: THREE.ImageUtils.loadTexture(modelsPath + 'textures/terrain/sand1.jpg')},
                    // Start blending in at height -80; opaque between -35 and 20; blend out by 50
                    {texture: THREE.ImageUtils.loadTexture(modelsPath + 'textures/terrain/grass1.jpg'), levels: [5, 5, 10, 5]},
                    {texture: THREE.ImageUtils.loadTexture(modelsPath + 'textures/terrain/stone1.jpg'), levels: [15, 20, 30, 10]},
                    // How quickly this texture is blended in depends on its x-position.
                    {texture: THREE.ImageUtils.loadTexture(modelsPath + 'textures/terrain/grass1.jpg'), glsl: '1.0 - smoothstep(65.0 + smoothstep(-256.0, 256.0, vPosition.x) * 80.0, 150.0, vPosition.z)'},
                    // Use this texture if the slope is between 27 and 45 degrees
                    {texture: THREE.ImageUtils.loadTexture(modelsPath + 'textures/terrain/stone1.jpg'), glsl: 'slope > 0.7853981633974483 ? 0.2 : 1.0 - smoothstep(0.47123889803846897, 0.7853981633974483, slope) + 0.2'}
                ]);

                //Generate
                var heightmapImage = new Image();
                heightmapImage.src = modelsPath + 'textures/terrain/heightmap.png';

                heightmapImage.onload = function() {generate()};

                var terrainScene;

                function generate(){
                    var xS = 127, yS = 127;
                    var terrain = {
                        easing: THREE.Terrain.Linear,
                        frequency: 2.5,
                        heightmap: heightmapImage,
                        material: tmaterial,
                        maxHeight: 20,
                        minHeight: -10,
                        steps: 1,
                        useBufferGeometry: false,
                        xSegments: xS,
                        xSize: 512,
                        ySegments: yS,
                        ySize: 512
                    };

                    terrainScene = THREE.Terrain(terrain);

                    var he = document.getElementById('heightmap');
                    if (terrain) {
                        terrain.heightmap = he;
                        THREE.Terrain.toHeightmap(terrainScene.children[0].geometry.vertices, terrain);
                    }

                    scene.add(terrainScene);

                    var physGeom = terrainScene.children[0].geometry;
                    var physMaterial = new Physijs.createMaterial(terrainScene.children[0].material, 10, 10);
                    physMaterial.visible = false;
                    var physObject = new Physijs.CapsuleMesh(physGeom, physMaterial, 0);

                    physObject.add(terrainScene.children[0]);
                    physObject.rotateX(-Math.PI /2);

                    scene.add(physObject);
                    console.log(physObject);
				}

                //

                var manager = new THREE.LoadingManager();
                manager.onProgress = function ( item, loaded, total ) {

                    console.log( item, loaded, total );

                };

                var texture = new THREE.Texture();

                var onProgress = function ( xhr ) {
                    if ( xhr.lengthComputable ) {
                        var percentComplete = xhr.loaded / xhr.total * 100;
                        console.log( Math.round(percentComplete, 2) + '% downloaded' );
                    }
                };

                var onError = function ( xhr ) {
                };


                var loader = new THREE.ImageLoader( manager );
                loader.load( modelsPath + 'obj/TR1/Wood03.png', function ( image ) {

                    texture.image = image;
                    texture.needsUpdate = true;

                } );

                // model

                var loader = new THREE.OBJLoader( manager );
                loader.load( modelsPath + 'obj/TR1/tr1.obj', function ( object ) {

                    object.traverse( function ( child ) {

                        if ( child instanceof THREE.Mesh ) {

                            child.material.map = texture;

                        }

                    } );

                    object.position.y = 12;
                    scene.add( object );


                }, onProgress, onError );


                var OBJloader = new THREE.OBJLoader();

                OBJloader.load('models/Objecten/TR1/tr1.obj',
                        function ( object ) {
                            scene.position.set(15, 12, 0);
                            scene.add( object );
                        }
                );


                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            //

            function animate() {

                requestAnimationFrame( animate );
                render();
                stats.update();

            }

            function render() {
                //var deltaTime = clock.getDelta();

                water.material.uniforms.time.value += 1.0 / 60.0;
                water.render();
                scene.simulate(); // run physics
                renderer.render( scene, camera );

            }

        </script>
	</body>
</html>
